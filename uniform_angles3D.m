function [ncells,nxa,mu,mu_b,pw] = uniform_angles3D(N)
%UNIFORM_ANGLES3D Generate uniform 3D discretization of mu
%   Specifically created for the Snake Coordinate solver, this simply returns
%   a mesh of the 2-sphere mu_x,mu_y,mu_z \in [-1,1] x [-1,1] x [-1,1]
%   with the constraint that mu_x^2 + mu_y^2 + mu_z^2 = 1 
%
%   Input: N-- Number of mu level cells in one \hat{k}^i dimension
%   (note, there are n+1, n/2+1 boundaries, including -1,1 and
%   0,1) N MUST BE EVEN, shoul be greater than 6

%   Since a uniform discretization will cluster rays near poles, best
%   to use with large N for good accuracy (but inefficient)
%
%   Output: ncells: total number of FV solid angle clells 
%   nxa: angular parameter coordinate dimensions. currently, it is 2-dim
%   with nxa(1) = N nxa(2) = N +1.   

% The algorithm discretizes theta \in [0, 2pi ), \phi \in [0, pi], then
% generates the boundary rays mu_b from these \theta,\phi
% 
% The actual sampling rays are generated by averaging the \theta,\phi of
% the boundary rays and then using spherical polar coordinates to convert
% to k^x, k^y, k^z

PLOT_OUTPUT = 0;

%DISCRETIZE THE PARAMETERS: THETA, PHI
%Do the entire 2-sphere
nxa = [N, N+1];
dtheta = 2*pi./(nxa(1)); %dont mesh all the way to 2pi!!!
dphi = pi./(nxa(2)-1);% theta = linspace(0,2.0*pi,N); % phi = linspace(0,pi,N/2);
theta = 0:dtheta:2.0*pi-dtheta;
phi = 0:dphi:pi;
%lets use average of angles to ensure normalizaiton
mu_b = zeros(nxa(1),nxa(2),3);
mu = zeros(nxa(1),nxa(2)-1,3); %identify with left, top boundaries
ncells= nxa(1)*(nxa(2)-1);
%THE NXA(1) = NXA(2) CASE IS CONVENIENT FOR ANGULAR_FLUX.M USE OF SPHERE()
%plotting function

%------------------CELL BOUNDARIES -------------------
%rows are theta bins, columns are phi bins
kx = cos(theta)'*sin(phi);
ky = sin(theta)'*sin(phi);
kz = ones(N,1)*cos(phi);
%THESE ARE IN LOCAL SNAKE BASIS, NOT CARTESIAN!!
mu_b(:,:,1) = kx;
mu_b(:,:,2) = ky;
mu_b(:,:,3) = kz;
%periodicity of the domain implies duplication of 1 theta bin
%first and last column/row are identical for kx, ky

%--------------SAMPLING ANGLES AS AVERAGES OF BOUNDARY RAYS----------------
for i=1:nxa(1)-1
    for j=1:nxa(2)-1
        mu(i,j,1) = cos((theta(i) + theta(i+1))./2)*sin((phi(j) + phi(j+1))./2);
        mu(i,j,2) = sin((theta(i) + theta(i+1))./2)*sin((phi(j) + phi(j+1))./2);
        mu(i,j,3) = cos((phi(j) + phi(j+1))./2);
    end
end
%wrap around theta dimension. the first angle should be theta=2pi, not
%theta=0. This matters for averaging, otherwise you wont get hte last theta
%ray
for j=1:nxa(2)-1
        mu(N,j,1) = cos((theta(N) + 2*pi)./2)*sin((phi(j) + phi(j+1))./2);
        mu(N,j,2) = sin((theta(N) + 2*pi)./2)*sin((phi(j) + phi(j+1))./2);
        mu(N,j,3) = cos((phi(j) + phi(j+1))./2);
end

%------------------CALCULATE QUADRATURE WEIGHTS -------------------
% Should this be proportional to the "size of the cell"?
pw = 1./(ncells)*ones(nxa(1),nxa(2)-1);

%---------------------------- PLOT RAYS ------------------------------
if PLOT_OUTPUT
    %plot circles at each mu_z in x-y plane
    t=0:0.01:2*pi;
    st = sin(t);
    ct = cos(t);
    figure(1);
    figure('Name','Local spherical discretization','NumberTitle','off')

    hold on;
    for i=1:nxa(2) %at fixed phi. in x-y plane, doesnt include poles
         radius = sqrt(1-cos(phi(i)).^2);
         plot3(radius*st,radius*ct,cos(phi(i))*ones(size(t)),'-k'); 
    end
    %these polar semicircles are at fixed theta. 
    t=0:0.01:pi;
    st = sin(t);
    ct = cos(t);
    for i=1:nxa(1)
         radius = 1.0;
         plot3(cos(theta(i))*st,sin(theta(i))*st,radius*ct,'-k'); 
    end

    for i=1:nxa(1)
        for j=1:nxa(2)
            quiver3(0,0,0,kx(i,j),ky(i,j),kz(i,j),0,'.b')
        end
    end
    %plot representative vectors
    for i=1:nxa(1)
        for j=1:nxa(2)-1
            quiver3(0,0,0,mu(i,j,1),mu(i,j,2),mu(i,j,3),0,'r')
        end
    end
    xlabel('x');
    ylabel('y');
    zlabel('z');
    hold off;
end

end

